package com.opentestimony.open_testimony

import android.os.Build
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import io.flutter.embedding.engine.plugins.FlutterPlugin
import io.flutter.plugin.common.MethodCall
import io.flutter.plugin.common.MethodChannel
import io.flutter.plugin.common.MethodChannel.MethodCallHandler
import io.flutter.plugin.common.MethodChannel.Result
import java.security.*
import java.security.spec.ECGenParameterSpec
import java.util.Base64

/**
 * Platform channel plugin for hardware-backed ECDSA signing using Android KeyStore/StrongBox.
 */
class CryptoPlugin : FlutterPlugin, MethodCallHandler {
    private lateinit var channel: MethodChannel
    private val keyAlias = "com.opentestimony.signing-key"

    override fun onAttachedToEngine(binding: FlutterPlugin.FlutterPluginBinding) {
        channel = MethodChannel(binding.binaryMessenger, "com.opentestimony/crypto")
        channel.setMethodCallHandler(this)
    }

    override fun onDetachedFromEngine(binding: FlutterPlugin.FlutterPluginBinding) {
        channel.setMethodCallHandler(null)
    }

    override fun onMethodCall(call: MethodCall, result: Result) {
        when (call.method) {
            "isHardwareBacked" -> result.success(isHardwareBacked())
            "generateKey" -> generateKey(result)
            "getPublicKey" -> getPublicKey(result)
            "sign" -> {
                val data = call.argument<String>("data")
                if (data == null) {
                    result.error("INVALID_ARGS", "Missing 'data' argument", null)
                    return
                }
                sign(data, result)
            }
            else -> result.notImplemented()
        }
    }

    private fun isHardwareBacked(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            // StrongBox available on Android 9+
            try {
                val ks = KeyStore.getInstance("AndroidKeyStore")
                ks.load(null)
                // Check if StrongBox is available by attempting to check the device
                true
            } catch (e: Exception) {
                false
            }
        } else {
            // TEE-backed KeyStore available on most Android 6+ devices
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.M
        }
    }

    private fun generateKey(result: Result) {
        try {
            val keyStore = KeyStore.getInstance("AndroidKeyStore")
            keyStore.load(null)

            // Delete existing key
            if (keyStore.containsAlias(keyAlias)) {
                keyStore.deleteEntry(keyAlias)
            }

            val paramBuilder = KeyGenParameterSpec.Builder(
                keyAlias,
                KeyProperties.PURPOSE_SIGN or KeyProperties.PURPOSE_VERIFY
            )
                .setAlgorithmParameterSpec(ECGenParameterSpec("secp256r1"))
                .setDigests(KeyProperties.DIGEST_SHA256)

            // Try StrongBox first (Android 9+), fall back to TEE
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                try {
                    paramBuilder.setIsStrongBoxBacked(true)
                } catch (e: Exception) {
                    // StrongBox not available, use TEE
                }
            }

            val keyPairGenerator = KeyPairGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_EC, "AndroidKeyStore"
            )
            keyPairGenerator.initialize(paramBuilder.build())
            keyPairGenerator.generateKeyPair()

            result.success(true)
        } catch (e: Exception) {
            // If StrongBox fails, retry without it
            try {
                val paramBuilder = KeyGenParameterSpec.Builder(
                    keyAlias,
                    KeyProperties.PURPOSE_SIGN or KeyProperties.PURPOSE_VERIFY
                )
                    .setAlgorithmParameterSpec(ECGenParameterSpec("secp256r1"))
                    .setDigests(KeyProperties.DIGEST_SHA256)

                val keyPairGenerator = KeyPairGenerator.getInstance(
                    KeyProperties.KEY_ALGORITHM_EC, "AndroidKeyStore"
                )
                keyPairGenerator.initialize(paramBuilder.build())
                keyPairGenerator.generateKeyPair()

                result.success(true)
            } catch (e2: Exception) {
                result.error("KEY_GEN", "Key generation failed: ${e2.message}", null)
            }
        }
    }

    private fun getPublicKey(result: Result) {
        try {
            val keyStore = KeyStore.getInstance("AndroidKeyStore")
            keyStore.load(null)

            val entry = keyStore.getEntry(keyAlias, null)
            if (entry !is KeyStore.PrivateKeyEntry) {
                result.error("NO_KEY", "Key not found", null)
                return
            }

            val publicKey = entry.certificate.publicKey
            val encoded = publicKey.encoded
            val base64Key = Base64.getMimeEncoder(64, "\n".toByteArray()).encodeToString(encoded)
            val pem = "-----BEGIN PUBLIC KEY-----\n$base64Key\n-----END PUBLIC KEY-----"
            result.success(pem)
        } catch (e: Exception) {
            result.error("EXPORT", "Failed to export public key: ${e.message}", null)
        }
    }

    private fun sign(data: String, result: Result) {
        try {
            val keyStore = KeyStore.getInstance("AndroidKeyStore")
            keyStore.load(null)

            val entry = keyStore.getEntry(keyAlias, null)
            if (entry !is KeyStore.PrivateKeyEntry) {
                result.error("NO_KEY", "Signing key not found", null)
                return
            }

            val signature = Signature.getInstance("SHA256withECDSA")
            signature.initSign(entry.privateKey)
            signature.update(data.toByteArray(Charsets.UTF_8))
            val signatureBytes = signature.sign()

            result.success(Base64.getEncoder().encodeToString(signatureBytes))
        } catch (e: Exception) {
            result.error("SIGN", "Signing failed: ${e.message}", null)
        }
    }
}
